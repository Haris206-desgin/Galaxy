<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ironman Particle Interface v3</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #status { position: absolute; top: 20px; left: 20px; color: #00ffff; z-index: 100; font-size: 14px; text-shadow: 0 0 8px #00ffff; }
        .video-box { position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; border: 1px solid #00ffff; border-radius: 8px; overflow: hidden; transform: scaleX(-1); opacity: 0.7; }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="status">System: Loading Shapes & AI...</div>
    <div class="video-box"><video id="input_video" playsinline></video></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const status = document.getElementById('status');
        const videoElement = document.getElementById('input_video');

        // 1. Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 50;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Particle Geometry
        const count = 15000;
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const targets = new Float32Array(count * 3);
        
        for(let i=0; i<count*3; i++) {
            positions[i] = (Math.random()-0.5) * 100;
            targets[i] = positions[i];
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({ size: 0.18, color: 0x00ffff, transparent: true, blending: THREE.AdditiveBlending });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // 3. Shape Math Functions
        function updateShape(type) {
            const targetArr = targets;
            for(let i=0; i<count; i++) {
                let x, y, z;
                if(type === 'heart') {
                    let t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random()-0.5) * 5;
                    const s = 1.2; x*=s; y*=s; z*=s;
                } else if(type === 'saturn') {
                    if(Math.random() > 0.4) { // Ring
                        let a = Math.random()*Math.PI*2; let r = 18 + Math.random()*6;
                        x = Math.cos(a)*r; z = Math.sin(a)*r; y = (Math.random()-0.5)*2;
                    } else { // Planet
                        let a = Math.random()*Math.PI*2; let b = Math.acos(Math.random()*2-1);
                        let r = 11; x = r*Math.sin(b)*Math.cos(a); y = r*Math.sin(b)*Math.sin(a); z = r*Math.cos(b);
                    }
                } else if(type === 'flower') {
                    let t = Math.random()*Math.PI*2;
                    let r = 18 * Math.cos(5 * t) * Math.sqrt(Math.random());
                    x = r * Math.cos(t); y = r * Math.sin(t); z = (Math.random()-0.5)*3;
                } else { // Fireworks (Spread)
                    let a = Math.random()*Math.PI*2; let b = Math.acos(Math.random()*2-1);
                    let r = 30 * Math.pow(Math.random(), 0.5);
                    x = r*Math.sin(b)*Math.cos(a); y = r*Math.sin(b)*Math.sin(a); z = r*Math.cos(b);
                }
                targetArr[i*3] = x; targetArr[i*3+1] = y; targetArr[i*3+2] = z;
            }
        }

        // 4. AI Tracking Logic
        let currentShape = 'none';
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.6});

        hands.onResults((res) => {
            if (res.multiHandLandmarks.length > 0) {
                const lm = res.multiHandLandmarks[0];
                const y = lm[9].y; // Middle knuckle height
                const x = lm[9].x; // Middle knuckle side
                
                // Color change based on Hand Side
                mat.color.setHSL(x, 1.0, 0.5);

                // Shape selection based on Height
                let nextShape = 'flower';
                if(y < 0.3) nextShape = 'saturn';
                else if(y < 0.6) nextShape = 'heart';
                
                // Fireworks logic: Pinch distance (Thumb & Index)
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if(pinch > 0.4) nextShape = 'fireworks'; // Hand wide open

                if(nextShape !== currentShape) {
                    currentShape = nextShape;
                    updateShape(nextShape);
                    status.innerHTML = `SYSTEM: SHAPE CHANGED TO <span style="color:#fff">${nextShape.toUpperCase()}</span>`;
                }
                
                points.rotation.y += (x - 0.5) * 0.1;
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        // 5. Smooth Animation
        function animate() {
            requestAnimationFrame(animate);
            const posAttr = geo.attributes.position.array;
            for(let i=0; i<count*3; i++) {
                // Smoothly move from current position to target position
                posAttr[i] += (targets[i] - posAttr[i]) * 0.1; 
            }
            geo.attributes.position.needsUpdate = true;
            points.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html> -->












<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ironman Particle System - Fixed & Shapes</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #status { position: absolute; top: 20px; left: 20px; color: #00ffff; z-index: 100; font-size: 14px; text-shadow: 0 0 10px #00ffff; }
        .video-box { position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; border: 1px solid #00ffff; border-radius: 8px; overflow: hidden; transform: scaleX(-1); opacity: 0.8; }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="status">System: Loading Jarvis Modules...</div>
    <div class="video-box"><video id="input_video" playsinline></video></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const status = document.getElementById('status');
        const videoElement = document.getElementById('input_video');

        // 1. Three.js Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 50;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Particles Setup
        const count = 15000;
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const targets = new Float32Array(count * 3);
        
        // Initial Random Cloud
        for(let i=0; i<count*3; i++) {
            positions[i] = (Math.random()-0.5) * 100;
            targets[i] = positions[i];
        }
        
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({ 
            size: 0.2, 
            color: 0x00ffff, 
            transparent: true, 
            blending: THREE.AdditiveBlending,
            depthWrite: false 
        });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // 3. Shape Math (Saturn, Heart, Flower, Fireworks)
        function generateShape(type) {
            for(let i=0; i<count; i++) {
                let x, y, z;
                if(type === 'heart') {
                    let t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random()-0.5) * 5;
                    const scale = 1.2; x*=scale; y*=scale; z*=scale;
                } else if(type === 'saturn') {
                    if(Math.random() > 0.4) { // Rings
                        let angle = Math.random() * Math.PI * 2;
                        let r = 18 + Math.random() * 6;
                        x = Math.cos(angle) * r; z = Math.sin(angle) * r; y = (Math.random()-0.5) * 2;
                    } else { // Planet Sphere
                        let angle = Math.random() * Math.PI * 2;
                        let phi = Math.acos(Math.random() * 2 - 1);
                        let r = 11;
                        x = r * Math.sin(phi) * Math.cos(angle);
                        y = r * Math.sin(phi) * Math.sin(angle);
                        z = r * Math.cos(phi);
                    }
                } else if(type === 'flower') {
                    let t = Math.random() * Math.PI * 2;
                    let r = 18 * Math.cos(5 * t) * Math.sqrt(Math.random());
                    x = r * Math.cos(t); y = r * Math.sin(t); z = (Math.random()-0.5) * 3;
                } else { // Fireworks / Explosion
                    let angle = Math.random() * Math.PI * 2;
                    let phi = Math.acos(Math.random() * 2 - 1);
                    let r = 35 * Math.pow(Math.random(), 0.3);
                    x = r * Math.sin(phi) * Math.cos(angle);
                    y = r * Math.sin(phi) * Math.sin(angle);
                    z = r * Math.cos(phi);
                }
                targets[i*3] = x; targets[i*3+1] = y; targets[i*3+2] = z;
            }
        }

        // 4. AI Hand Tracking (Fixing the Model Load Error)
        const hands = new Hands({
            locateFile: (file) => {
                // Manually specifying the path to avoid "Failed to read file" error
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        let currentShape = 'none';
        hands.onResults((res) => {
            if (res.multiHandLandmarks.length > 0) {
                status.innerHTML = "SYSTEM: <span style='color:#0f0'>GALAXY INTERFACE ACTIVE</span>";
                const lm = res.multiHandLandmarks[0];
                
                // 1. Color Change (Based on Hand X)
                mat.color.setHSL(lm[9].x, 1.0, 0.5);

                // 2. Shape Switch (Based on Hand Y)
                let next = 'flower';
                if(lm[9].y < 0.3) next = 'saturn';
                else if(lm[9].y < 0.6) next = 'heart';

                // 3. Fireworks Gesture (Pinch Open)
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                if(pinch > 0.45) next = 'fireworks';

                if(next !== currentShape) {
                    currentShape = next;
                    generateShape(next);
                }

                // 4. Interaction (Rotation)
                points.rotation.y += (lm[9].x - 0.5) * 0.05;
            } else {
                status.innerText = "System: Waiting for Hand Calibration...";
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start().then(() => { status.innerText = "System: Camera Initialized. Looking for Hand..."; });

        // 5. Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            const posAttr = geo.attributes.position.array;
            for(let i=0; i<count*3; i++) {
                // Smooth Morphing Factor
                posAttr[i] += (targets[i] - posAttr[i]) * 0.1;
            }
            geo.attributes.position.needsUpdate = true;
            points.rotation.y += 0.003;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>